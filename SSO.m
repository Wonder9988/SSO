%SSO source code v2.0, Generated by Hisham A. Shehadeh, 2021. 

			      %-------------------------------------------%
                              %         Adopted from:                     %           
                              %-------------------------------------------%

%Shehadeh, H. A. (2021). A hybrid sperm swarm optimization and gravitational search algorithm (HSSOGSA) 
%for global optimization. Neural Computing and Applications, 1-14.

 			      %-------------------------------------------%
                              %         Adopted from:                     %           
                              %-------------------------------------------%
% Shehadeh, H. A., Ahmedy, I., & Idris, M. Y. I. (2018, September). 
%Empirical study of sperm swarm optimization algorithm. 
%In Proceedings of SAI Intelligent Systems Conference (pp. 1082-1104). Springer, Cham.

			      %-------------------------------------------%
                              %         Adopted from:                     %           
                              %-------------------------------------------%

%Shehadeh, H. A., Ahmedy, I., & Idris, M. Y. I. (2018, February). 
%Sperm swarm optimization algorithm for optimizing wireless sensor network challenges. 
%In Proceedings of the 6th International Conference on Communications and Broadband Networking (pp. 53-59).


                              %-------------------------------------------%
                              %         Evaluate the population           %           
                              %-------------------------------------------%                                 %--%
 %%% Variables %%%

%current_position:  Position of sperms
%velocity:          Velocity
%dim:               Dimension of test functions
%n:                 Number of sperms
%low:               The lower bound of the search space
%up:                The higher bound of the search space

%% Note: This version of the code is without mutation part in which is a secondary thing.
function [sgBestScore,sgBest,GlobalBestCost]=SSO(Benchmark_Function_ID,n,iteration)

[low,up,dim]=benchmark_functions_details(Benchmark_Function_ID);%define the boundary and dimension of the benchmark function

current_fitness =zeros(n,1);
sgBest=zeros(1,dim);
sgBestScore=inf;

swarm=zeros(n,3); % to swarm
step = 1;
for i = 1 : n % to swarm
swarm(step, 1:3) = i;
step = step + 1;
end
swarm(:, 3) = 0  ;       % Greater than maximum possible value
swarm(:, 2) = 0 ;         % initial velocity
swarm(:, 1) = 0  ;        % initial velocity


for i=1:n
        sBestScore(i)=inf;
        
end
        sBest=zeros(n,dim);
        sgbest=zeros(n,dim);
      


Boundary_no = size(up',2);

if Boundary_no==1
    current_position = rand(n,dim).*(up-low)+low; %initial positions in the problem's boundary
end

% If each variable has a different up and low
if Boundary_no>1
    for i=1:dim
        up_i=up(i,1);
        low_i=low(i,1);
       current_position(:,i)=rand(n,1).*(up_i-low_i)+low_i; %initial positions in the problem's boundary
    end
end


velocity = .3*randn(n,dim) ;

%%main loop
iter = 0 ;                  % Iterationsâ€™ counter
while  ( iter < iteration )


iter = iter + 1;
iter;


for i = 1:n
    fitness=0;
    %///Bound the search Space///
    %Tp=current_position(i,:)>up;Tm=current_position(i,:)<low;current_position(i,:)=(current_position(i,:).*(~(Tp+Tm)))+up.*Tp+low.*Tm;                     
    
    Flag4up=current_position(i,:)>up';
    Flag4low=current_position(i,:)<low';
    current_position(i,:)=(current_position(i,:).*(~(Flag4up+Flag4low)))+up'.*Flag4up+low'.*Flag4low; 

    %////////////////////////////
    
                                 %-------------------------------------------%
                                 %         Evaluate the population           %           
                                 %-------------------------------------------%      
       %-- position of Swarms ---
    fitness=benchmark_functions(current_position(i,:),Benchmark_Function_ID,dim);
    current_fitness(i)=fitness;
        for j=1:dim
        swarm(i, 1) = swarm(i, 1) +  velocity(i,j)/1.5 ;    %update u position (x-axis)

    

	if fitness < swarm(i, 3)          % Always True
       	swarm(i, 2) = swarm(i, 1);    % update sbest position of u,
            swarm(i, 3) = fitness ;         % best updated minimum value
    end
        end
   
                                 
    [temp, ggbest] = min(swarm(:, 3));        % sgbest position
       
        
    if(sBestScore(i)>fitness)
        sBestScore(i)=fitness;
        sBest(i,:)=current_fitness(i,:);
       
         
         
    end
    if(sgBestScore>fitness)
        sgBestScore=fitness;
        sgBest=current_position(i,:);
    end
    
    
    
end

best=min(current_fitness);
worst=max(current_fitness);

        GlobalBestCost(iter)=sgBestScore;
        GlobalBestCost(iter);
        best;

    for pp=1:n
        if current_fitness(pp)==best
            break;
        end
        
    end
    
    bestIndex=pp;
            
    for pp=1:dim
        best_fit_position(iter,1)=best;
        best_fit_position(iter,pp+1)=current_position(bestIndex,pp);   
    end
                                          
                                               %------------------------------------%
                                               %  Velocities  UPDATE  %
                                               %------------------------------------%
  

for i=1:n
        for j=1:dim
            
                velocity(i,j)=rand()*(log10((7-14)*rand(1,1)+7))*velocity(i,j)+(log10((7-14)*rand(1,1)+7))* (log10((35.5-38.5)*rand(1,1)+35.5))*(swarm(i,3)-current_position(i,j))...
                +(log10((7-14)*rand(1,1)+7))* (log10((35.5-38.5)*rand(1,1)+35.5))*(sgBest(j)-current_position(i,j));
        end
end
                                               %--------------------------%
                                               %   positions   UPDATE     %
                                               %--------------------------%
                                                        

current_position = current_position + velocity ;
 
end
end


